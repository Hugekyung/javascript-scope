# JavaScript Scope - Block Level

`let, const 기반의 자바스크립트 블록레벨 스코프`

## 개요

ES6가 등장하면서 자바스크립트에는 let과 const 기반의 블록레벨 스코프가 추가되었다. 그 이유는 기존의 var 기반의 변수선언이 각종 문제를 야기하기 때문이다.

<br/>

`함수 레벨 스코프`

-   ES6 이전 자바스크립트는 함수레벨 스코프만을 인정한다.
-   함수 외부에서 생성한 변수는 모두 전역변수이고, 이는 전역변수를 남발할 수 있다는 가능성을 높인다.
-   for문의 변수 선언문에서 선언한 변수를 for문의 코드블록 외부에서 참조할 수 있는 문제가 있었다.

```js
var x = "global";

for (var i = 0; i < 10; i++) {
    x = "local";
}

console.log(x); // local - for loop 내부에서 변수 x 재할당 가능
```

`var 키워드 생략 허용`

-   암묵적 전역 변수의 양산 가능성이 크다.

`변수 중복 선언 허용`

-   의도하지 않은 변수 값의 변경이 일어날 가능성이 크다.

`변수 호이스팅`

-   변수 선언 이전에 참조하는 문제가 발생할 수 있다.

<br/>

이처럼 var기반 변수선언 방식은 다양한 문제를 안고 있었다. 물론 간단한 애플리케이션의 경우에는 간단하고 편리하게 사용할 수 있는 장점이 있지만, 코드가 복잡해지고 프로젝트의 규모가 커질수록 전역변수 사용에 따른 문제가 발생할 수 있다. 따라서 변수의 스코프를 좁은 단위로 관리할 수 있게 도와주는 `let`과 `const`가 ES6에서 도입되었다.

<br/>

## let

-   자바스크립트에서는 기본적으로 함수레벨 스코프를 따른다.
-   foo라는 변수는 전역에서 생성되었고, 블록 레벨에서 465라는 값으로 재선언 및 재할당되었다(기존의 foo를 덮어쓴다).
-   즉, var 키워드로 선언할 경우 변수 중복 선언이 가능하다.

```js
var foo = 123; // 전역 변수

console.log(foo); // 123

{
    var foo = 456; // 전역 변수
}

console.log(foo); // 456
```

<br/>

### 블록레벨 스코프

-   하지만 let 키워드를 통해 변수를 선언한 경우, 블록레벨 스코프를 따른다.
-   bar변수는 블록 내에서 선언되었기 때문에, 전역에서는 참조할 수 없다.

```js
let foo = 123; // 전역 변수

{
    let foo = 456; // 지역 변수
    let bar = 456; // 지역 변수
}

console.log(foo); // 123
console.log(bar); // ReferenceError: bar is not defined
```

<br/>

### 변수 중복 선언 금지

-   let 키워드로 변수를 선언할 경우 동일한 이름을 중복해서 사용할 수 없다.

```js
var foo = 123;
var foo = 456; // 중복 선언 허용

let bar = 123;
let bar = 456; // Uncaught SyntaxError: Identifier 'bar' has already been declared
```

<br/>

### 호이스팅

호이스팅이란 var 선언문이나 function 선언문 등을 해당 스코프의 선두로 옮긴 것처럼 동작하는 특성을 말한다. 하지만 let 키워드를 통해 선언된 변수의 경우에는 호이스팅되지 않고 참조 에러를 발생한다.<br/>
var와 달리 let 키워드를 통한 선언에서는 호이스팅이 되지 않는 이유는 두 키워드를 사용한 변수 생성에서의 단계가 다르게 동작하기 때문이다.

<br/>

`변수 생성의 3단계`

> 선언 단계<br/>

-   변수를 실행 컨텍스트의 변수 객체(Variable Object)에 등록
-   이 변수 객체는 스코프가 참조하는 대상이 됨

> 초기화 단계<br/>

-   변수 객체(Variable Object)에 등록된 변수를 위한 공간을 메모리에 확보
-   이 단계에서 변수는 undefined로 초기화

> 할당 단계<br/>

-   undefined로 초기화된 변수에 실제 값을 할당

<br/>

`var와 let 키워드의 변수 생성 과정 비교`

-   var 키워드로 선언된 변수는 선언 단계와 초기화 단계가 한번에 이루어진다.
-   스코프에 변수를 선언하고 메모리에 변수를 위한 공간을 확보한 뒤, undefined로 초기화한다.
-   스코프의 선두에서 선언 단계와 초기화 단계가 실행된다.
-   따라서 변수 선언문 이전에 변수를 참조할 수 있다.

```js
console.log(foo); // undefined, 선언 + 초기화 단계 이후의 상태가 호이스팅된다

var foo;
console.log(foo); // undefined

foo = 1; // 할당문에서 할당 단계가 실행된다
console.log(foo); // 1
```

<br/>

-   let 키워드로 선언된 변수는 선언 단계와 초기화 단계가 분리되어 진행된다.
-   스코프에 변수를 등록하지만 초기화 단계는 변수 선언문에 도달했을 때 이루어진다.
-   var처럼 호이스팅을 하려고 하면 참조에러가 발생하는데, 이는 아직 메모리에 변수를 위한 공간이 확보되지 않았기 때문이다.
-   스코프의 시작 지점부터 초기화 시작 지점까지의 구간을 ‘일시적 사각지대(Temporal Dead Zone; TDZ)’라고 부른다.

```js
console.log(foo); // ReferenceError: foo is not defined

let foo; // 변수 선언문에서 초기화 단계가 실행된다
console.log(foo); // undefined

foo = 1; // 할당문에서 할당 단계가 실행된다
console.log(foo); // 1
```
