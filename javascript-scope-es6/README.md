# JavaScript Scope - Block Level

`let, const 기반의 자바스크립트 블록레벨 스코프`

## 1. 개요(ES6가 등장한 이유 : var 변수 선언의 문제점)

ES6가 등장하면서 자바스크립트에는 let과 const 기반의 블록레벨 스코프가 추가되었다. 그 이유는 기존의 var 기반의 변수선언이 각종 문제를 야기하기 때문이다.

<br/>

`함수 레벨 스코프`

-   ES6 이전 자바스크립트는 함수레벨 스코프만을 인정한다.
-   함수 외부에서 생성한 변수는 모두 전역변수이고, 이는 전역변수를 남발할 수 있다는 가능성을 높인다.
-   for문의 변수 선언문에서 선언한 변수를 for문의 코드블록 외부에서 참조할 수 있는 문제가 있었다.

```js
var x = "global";

for (var i = 0; i < 10; i++) {
    x = "local";
}

console.log(x); // local - for loop 내부에서 변수 x 재할당 가능
```

`var 키워드 생략 허용`

-   암묵적 전역 변수의 양산 가능성이 크다.

`변수 중복 선언 허용`

-   의도하지 않은 변수 값의 변경이 일어날 가능성이 크다.

`변수 호이스팅`

-   변수 선언 이전에 참조하는 문제가 발생할 수 있다.

<br/>

이처럼 var기반 변수선언 방식은 다양한 문제를 안고 있었다. 물론 간단한 애플리케이션의 경우에는 간단하고 편리하게 사용할 수 있는 장점이 있지만, 코드가 복잡해지고 프로젝트의 규모가 커질수록 전역변수 사용에 따른 문제가 발생할 수 있다. 따라서 변수의 스코프를 좁은 단위로 관리할 수 있게 도와주는 `let`과 `const`가 ES6에서 도입되었다.

<br/>

## 2. let

-   자바스크립트에서는 기본적으로 함수레벨 스코프를 따른다.
-   foo라는 변수는 전역에서 생성되었고, 블록 레벨에서 465라는 값으로 재선언 및 재할당되었다(기존의 foo를 덮어쓴다).
-   즉, var 키워드로 선언할 경우 변수 중복 선언이 가능하다.

```js
var foo = 123; // 전역 변수

console.log(foo); // 123

{
    var foo = 456; // 전역 변수
}

console.log(foo); // 456
```

<br/>

### 블록레벨 스코프

-   하지만 let 키워드를 통해 변수를 선언한 경우, 블록레벨 스코프를 따른다.
-   bar변수는 블록 내에서 선언되었기 때문에, 전역에서는 참조할 수 없다.

```js
let foo = 123; // 전역 변수

{
    let foo = 456; // 지역 변수
    let bar = 456; // 지역 변수
}

console.log(foo); // 123
console.log(bar); // ReferenceError: bar is not defined
```

<br/>

### 변수 중복 선언 금지

-   let 키워드로 변수를 선언할 경우 동일한 이름을 중복해서 사용할 수 없다.

```js
var foo = 123;
var foo = 456; // 중복 선언 허용

let bar = 123;
let bar = 456; // Uncaught SyntaxError: Identifier 'bar' has already been declared
```

<br/>

### 호이스팅

호이스팅이란 var 선언문이나 function 선언문 등을 해당 스코프의 선두로 옮긴 것처럼 동작하는 특성을 말한다. 하지만 let 키워드를 통해 선언된 변수의 경우에는 호이스팅되지 않고 참조 에러를 발생한다.<br/>
var와 달리 let 키워드를 통한 선언에서는 호이스팅이 되지 않는 이유는 두 키워드를 사용한 변수 생성에서의 단계가 다르게 동작하기 때문이다.

<br/>

`변수 생성의 3단계`

> 선언 단계<br/>

-   변수를 실행 컨텍스트의 변수 객체(Variable Object)에 등록
-   이 변수 객체는 스코프가 참조하는 대상이 됨

> 초기화 단계<br/>

-   변수 객체(Variable Object)에 등록된 변수를 위한 공간을 메모리에 확보
-   이 단계에서 변수는 undefined로 초기화

> 할당 단계<br/>

-   undefined로 초기화된 변수에 실제 값을 할당

<br/>

`var와 let 키워드의 변수 생성 과정 비교`

-   var 키워드로 선언된 변수는 선언 단계와 초기화 단계가 한번에 이루어진다.
-   스코프에 변수를 선언하고 메모리에 변수를 위한 공간을 확보한 뒤, undefined로 초기화한다.
-   스코프의 선두에서 선언 단계와 초기화 단계가 실행된다.
-   따라서 변수 선언문 이전에 변수를 참조할 수 있다.

```js
console.log(foo); // undefined, 선언 + 초기화 단계 이후의 상태가 호이스팅된다

var foo;
console.log(foo); // undefined

foo = 1; // 할당문에서 할당 단계가 실행된다
console.log(foo); // 1
```

<br/>

-   let 키워드로 선언된 변수는 선언 단계와 초기화 단계가 분리되어 진행된다.
-   스코프에 변수를 등록하지만 초기화 단계는 변수 선언문에 도달했을 때 이루어진다.
-   var처럼 호이스팅을 하려고 하면 참조에러가 발생하는데, 이는 아직 메모리에 변수를 위한 공간이 확보되지 않았기 때문이다.
-   스코프의 시작 지점부터 초기화 시작 지점까지의 구간을 ‘일시적 사각지대(Temporal Dead Zone; TDZ)’라고 부른다.

```js
console.log(foo); // ReferenceError: foo is not defined

let foo; // 변수 선언문에서 초기화 단계가 실행된다
console.log(foo); // undefined

foo = 1; // 할당문에서 할당 단계가 실행된다
console.log(foo); // 1
```

<br/>

## 3. const

const는 상수를 위해 사용하지만 반드시 상수만을 위해 사용되지는 않는다. const는 let과 특징이 대부분 동일하며 몇 가지 부분에서 차이가 있다.

<br/>

### 선언과 초기화

-   let 키워드를 통한 변수 선언은 재할당이 자유롭지만, const는 재할당이 금지된다.
-   const는 반드시 선언과 동시에 할당이 이루어져야 한다.

```js
const FOO = 123;
FOO = 456; // 재할당 불가, TypeError: Assignment to constant variable.

const FOO; // 변수 선언만 하는 것은 불가능, SyntaxError: Missing initializer in const declaration
```

<br/>

### 상수로써의 기능

-   const는 상수의 장점이라고 할 수 있는 가독성과 유지보수 측면의 편리함을 위해 적극적으로 활용할 수 있다.
-   const는 객체의 선언에도 사용할 수 있지만, 역시 재할당은 금지된다.

```js
// 10의 의미를 알기 어렵기 때문에 가독성이 좋지 않다.
if (rows > 10) {
}

// 값의 의미를 명확히 기술하여 가독성이 향상되었다.
const MAXROWS = 10;
if (rows > MAXROWS) {
}
```

<br/>

### const를 활용한 객체 선언

-   const는 객체 선언에도 활용할 수 있다.
-   하지만 앞선 특징과 마찬가지로 재할당은 금지되어 있는데, 주의할 점은 객체의 내용은 변경할 수 있다는 사실이다.
-   객체의 내용이 변경되더라도 객체 자체의 기존에 할당된 주소값은 변경되지 않으며, 객체의 프로퍼티를 추가하거나 삭제 혹은 변경을 할 수 있다.
-   따라서 명시적으로 객체를 재할당해야 하는 경우가 아니라면, const를 사용하는 것이 좋다.

```js
const user = { name: "Lee" };

// const 변수는 재할당이 금지된다.
user = {}; // TypeError: Assignment to constant variable.

// 객체의 내용은 변경할 수 있다.
user.name = "Kim";

console.log(user); // { name: 'Kim' }
```

<br/>

## 4. 결론(var vs let vs const) : const를 적극 활용하자!

-   변수 선언에는 기본적으로 const를 사용하고, 재할당이 필요할 경우에만 let을 사용하는 것이 좋다.
-   const를 통한 변수 선언을 하면 의도치 않은 재할당을 방지할 수 있어 안전하다는 장점이 있다.
-   변수를 선언할 시점에 해당 변수가 재할당이 필요할지 아닐지에 대한 판단을 내리기 어렵다면, `우선 const를 통한 변수 선언을 하자.` 이후 필요에 따라 let으로 변경해줘도 늦지 않다.

<br/>

> 추천사항

-   ES6+를 사용한다면 var 키워드는 사용하지 않는다.
-   재할당이 필요한 경우에 한정해 let 키워드를 사용한다. 이때 변수의 스코프는 최대한 좁게 만든다.
-   변경이 발생하지 않는(재할당이 필요 없는 상수) 값과 객체에는 const 키워드를 사용한다. const 키워드는 재할당을 금지하므로 var, let 보다 안전하다.

<br/>

### 참고

[let, const와 블록 레벨 스코프](https://poiemaweb.com/es6-block-scope)
