# JavaScript Scope - Block Level

`let, const 기반의 자바스크립트 블록레벨 스코프`

## 개요

ES6가 등장하면서 자바스크립트에는 let과 const 기반의 블록레벨 스코프가 추가되었다. 그 이유는 기존의 var 기반의 변수선언이 각종 문제를 야기하기 때문이다.

<br/>

`함수 레벨 스코프`

-   ES6 이전 자바스크립트는 함수레벨 스코프만을 인정한다.
-   함수 외부에서 생성한 변수는 모두 전역변수이고, 이는 전역변수를 남발할 수 있다는 가능성을 높인다.
-   for문의 변수 선언문에서 선언한 변수를 for문의 코드블록 외부에서 참조할 수 있는 문제가 있었다.

```js
var x = "global";

for (var i = 0; i < 10; i++) {
    x = "local";
}

console.log(x); // local - for loop 내부에서 변수 x 재할당 가능
```

`var 키워드 생략 허용`

-   암묵적 전역 변수의 양산 가능성이 크다.

`변수 중복 선언 허용`

-   의도하지 않은 변수 값의 변경이 일어날 가능성이 크다.

`변수 호이스팅`

-   변수 선언 이전에 참조하는 문제가 발생할 수 있다.

<br/>

이처럼 var기반 변수선언 방식은 다양한 문제를 안고 있었다. 물론 간단한 애플리케이션의 경우에는 간단하고 편리하게 사용할 수 있는 장점이 있지만, 코드가 복잡해지고 프로젝트의 규모가 커질수록 전역변수 사용에 따른 문제가 발생할 수 있다. 따라서 변수의 스코프를 좁은 단위로 관리할 수 있게 도와주는 `let`과 `const`가 ES6에서 도입되었다.

<br/>

## let

-   자바스크립트에서는 기본적으로 함수레벨 스코프를 따른다.
-   foo라는 변수는 전역에서 생성되었고, 블록 레벨에서 465라는 값으로 재선언 및 재할당되었다(기존의 foo를 덮어쓴다).
-   즉, var 키워드로 선언할 경우 변수 중복 선언이 가능하다.

```js
var foo = 123; // 전역 변수

console.log(foo); // 123

{
    var foo = 456; // 전역 변수
}

console.log(foo); // 456
```

<br/>

### 블록레벨 스코프

-   하지만 let 키워드를 통해 변수를 선언한 경우, 블록레벨 스코프를 따른다.
-   bar변수는 블록 내에서 선언되었기 때문에, 전역에서는 참조할 수 없다.

```js
let foo = 123; // 전역 변수

{
    let foo = 456; // 지역 변수
    let bar = 456; // 지역 변수
}

console.log(foo); // 123
console.log(bar); // ReferenceError: bar is not defined
```

### 변수 중복 선언 금지

-   let 키워드로 변수를 선언할 경우 동일한 이름을 중복해서 사용할 수 없다.

```js
var foo = 123;
var foo = 456; // 중복 선언 허용

let bar = 123;
let bar = 456; // Uncaught SyntaxError: Identifier 'bar' has already been declared
```

### 호이스팅
